webpackJsonp([0xc54baefaa45e0000],{"./node_modules/json-loader/index.js!./.cache/json/csharp-null-conditional-operator.json":function(e,n){e.exports={data:{markdownRemark:{html:'<h1>Null-conditional Operator</h1>\n<p>Null-conditional operators allow for null checking with a minimal amount of code. For example, if you had\nan employee variable of type Employee with a property of type Address, you might do null checking as follows:</p>\n<h2></h2>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>Address address = null;\nif (employee != null)\n{\n    address = employee.Address;\n}</code></pre>\n      </div>\n<p>You could use a standard conditional operator to make that check more concise:</p>\n<h2></h2>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>Address address = employee != null ? employee.Address : null;</code></pre>\n      </div>\n<p>However, in C# 6.0 null-conditional operators were introduced, so now the above line can simply\nbe represented as follows:</p>\n<h2></h2>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>Address address = student?.Address;</code></pre>\n      </div>\n<p>If employee is null, address will simply be assigned null, and no NullReferenceExeception will occur.\nThis becomes more useful with deeper object graphs, as you can handle a chain of conditional member access.\nFor example:</p>\n<h2></h2>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>string city = student?.Address?.City;</code></pre>\n      </div>\n<p>Null-conditional operators are short-circuiting, so as soon as one check of conditional member access\nreturns null, the rest do not take place.</p>',fields:{slug:"/csharp/null-conditional-operator/"},frontmatter:{title:"Null-conditional Operator"}}},pathContext:{slug:"/csharp/null-conditional-operator/"}}}});
//# sourceMappingURL=path---csharp-null-conditional-operator-1372ec1dd69038bfea40.js.map