{"version":3,"sources":["webpack:///path---algorithms-search-algorithms-jump-search-4a9691f58cb5680f4b12.js","webpack:///./.cache/json/algorithms-search-algorithms-jump-search.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/algorithms-search-algorithms-jump-search.json","module","exports","data","markdownRemark","html","fields","slug","frontmatter","title","pathContext"],"mappings":"AAAAA,cAAc,qBAERC,kGACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,wjCAA6cC,QAAooBC,KAAA,8CAAoDC,aAAgBC,MAAA,iBAAwBC,aAAgBH,KAAA","file":"path---algorithms-search-algorithms-jump-search-4a9691f58cb5680f4b12.js","sourcesContent":["webpackJsonp([17399838815116106000],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/algorithms-search-algorithms-jump-search.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Jump Search</h2>\\n<p>A jump search locates an item in a sorted array by jumping k itens and then verify if the item wanted is between\\nthe previous jump and current jump.</p>\\n<h1>Complexity Worst Case</h1>\\n<p>O(√N)</p>\\n<h1>Works</h1>\\n<ol>\\n<li>Define the value of k, the number of jump: Optimal jump size is √N where the N is the length of array</li>\\n<li>Jump the array k-by-k searching by the condition <code>Array[i] &#x3C; valueWanted &#x3C; Array[i+k]</code></li>\\n<li>Do a linear search between <code>Array[i]</code> and <code>Array[i + k]</code></li>\\n</ol>\\n<p><img src=\\\"https://i1.wp.com/theoryofprogramming.com/wp-content/uploads/2016/11/jump-search-1.jpg?resize=676%252C290\\\" alt=\\\"Jumping Search 1\\\"></p>\\n<h1>Code</h1>\\n<p>To view examples of code implementation of this method access this link below:</p>\\n<p><a href=\\\"https://github.com/OpenGenus/cosmos/tree/master/code/search/jump_search\\\">Jump Search - OpenGenus/cosmos</a></p>\\n<h1>Credits</h1>\\n<p><a href=\\\"http://theoryofprogramming.com/2016/11/10/jump-search-algorithm/\\\">The logic’s array image</a></p>\",\"fields\":{\"slug\":\"/algorithms/search-algorithms/jump-search/\"},\"frontmatter\":{\"title\":\"Jump Search\"}}},\"pathContext\":{\"slug\":\"/algorithms/search-algorithms/jump-search/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---algorithms-search-algorithms-jump-search-4a9691f58cb5680f4b12.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Jump Search</h2>\\n<p>A jump search locates an item in a sorted array by jumping k itens and then verify if the item wanted is between\\nthe previous jump and current jump.</p>\\n<h1>Complexity Worst Case</h1>\\n<p>O(√N)</p>\\n<h1>Works</h1>\\n<ol>\\n<li>Define the value of k, the number of jump: Optimal jump size is √N where the N is the length of array</li>\\n<li>Jump the array k-by-k searching by the condition <code>Array[i] &#x3C; valueWanted &#x3C; Array[i+k]</code></li>\\n<li>Do a linear search between <code>Array[i]</code> and <code>Array[i + k]</code></li>\\n</ol>\\n<p><img src=\\\"https://i1.wp.com/theoryofprogramming.com/wp-content/uploads/2016/11/jump-search-1.jpg?resize=676%252C290\\\" alt=\\\"Jumping Search 1\\\"></p>\\n<h1>Code</h1>\\n<p>To view examples of code implementation of this method access this link below:</p>\\n<p><a href=\\\"https://github.com/OpenGenus/cosmos/tree/master/code/search/jump_search\\\">Jump Search - OpenGenus/cosmos</a></p>\\n<h1>Credits</h1>\\n<p><a href=\\\"http://theoryofprogramming.com/2016/11/10/jump-search-algorithm/\\\">The logic’s array image</a></p>\",\"fields\":{\"slug\":\"/algorithms/search-algorithms/jump-search/\"},\"frontmatter\":{\"title\":\"Jump Search\"}}},\"pathContext\":{\"slug\":\"/algorithms/search-algorithms/jump-search/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/algorithms-search-algorithms-jump-search.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/algorithms-search-algorithms-jump-search.json\n// module chunks = 17399838815116106000"],"sourceRoot":""}