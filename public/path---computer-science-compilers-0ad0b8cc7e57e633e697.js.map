{"version":3,"sources":["webpack:///path---computer-science-compilers-0ad0b8cc7e57e633e697.js","webpack:///./.cache/json/computer-science-compilers.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/computer-science-compilers.json","module","exports","data","markdownRemark","html","fields","slug","frontmatter","title","pathContext"],"mappings":"AAAAA,cAAc,qBAERC,oFACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,oiJAAAC,QAA2jJC,KAAA,gCAAsCC,aAAgBC,MAAA,eAAsBC,aAAgBH,KAAA","file":"path---computer-science-compilers-0ad0b8cc7e57e633e697.js","sourcesContent":["webpackJsonp([10189783115851524000],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/computer-science-compilers.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Compilers</h2>\\n<h3>Programming</h3>\\n<p>At its heart, a barebones computer (aka a stored program computer) is nothing but a machine which knows how to read steps written in a fixed instruction set and execute the same. The set of instructions a computer understands is very specific to it. This is also known as machine language (<strong>opcodes</strong>). Machine Language is often alos referred to as Bianry Code.</p>\\n<p>Humans interact with computers using <strong>Programs</strong>. A program is simply a sequence of opcodes provided to the computer along with data that is necessary for executing the opcodes. </p>\\n<p>For example,</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>ADD 10, 20  // ADD is the Opcode \\n            // and 10, 20 are the two operands(data) \\n            // needed for the ADD instruction to be executed successfully</code></pre>\\n      </div>\\n<p>Humans develop programs to solve complex problems. Looking at how simple opcodes are, if we try to develop programs using opcodes alone, it will be very cumbersome and difficult to debug. To solve this problem, high level languages like C/C++, Python, Java, Javascript, etc were developed. </p>\\n<p>Now, high level languages aren’t suitable for execution by computers. Hence, the need arose for a translator that can digest the high-level language programs and convert them to machine language instructions suitable for execution by a computer.</p>\\n<h4>[HUMANS] -> [Highlevel language programs] -> [Translator] -> [Machine Language] -> [Computer]</h4>\\n<p>A <strong>compiler</strong> is a type of translator program, that translates high level languages into binary code, which is nothing but 1s and 0s. When you run your source code, a compiler translates all the code first, then produces the binary code. Then the computer takes the binary code and runs it.</p>\\n<p>If there are errors in your source code, the compiler detects and flags them. This stops the compilation process. Once all erros are fixed, the compiler converts the code and generates an executable program.</p>\\n<h2>Parts of a compiler</h2>\\n<p>Most compilers break down into three primary stages: Parsing, Transformation, and Code Generation</p>\\n<ol>\\n<li><em>Parsing</em> is taking raw code and turning it into a more abstract representation of the code.</li>\\n<li><em>Transformation</em> takes this abstract representation and manipulates to do whatever the compiler wants it to.</li>\\n<li><em>Code Generation</em> takes the transformed representation of the code and turns it into new code.</li>\\n</ol>\\n<h4>Parsing</h4>\\n<p>Parsing typically gets broken down into two phases: <strong>Lexical Analysis</strong> and <strong>Syntactic Analysis</strong>.</p>\\n<p><em>Lexical Analysis</em> takes the raw code and splits it apart into these things called tokens by a thing called a tokenizer (or lexer).</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>Tokens are an array of tiny little objects that describe an isolated piece of the syntax. \\nThey could be numbers, labels, punctuation, operators, etc.</code></pre>\\n      </div>\\n<p><em>Syntactic Analysis</em> takes the tokens and reformats them into a representation that describes each part of the syntax\\nand their relation to one another. This is known as an intermediate representation or Abstract Syntax Tree.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>An Abstract Syntax Tree, or AST for short, is a deeply nested object.\\nIt represents code in a way that is both easy to work with and tells us a lot of information.</code></pre>\\n      </div>\\n<h4>Transformation</h4>\\n<p>The next type of stage for a compiler is transformation. Again, this just takes the AST from the last step and makes changes to it.\\nIt can manipulate the AST in the same language or it can translate it into an entirely new language.</p>\\n<h4>Code Generation</h4>\\n<p>The final phase of a compiler is code generation. Sometimes compilers will do things that overlap with transformation, but for the most part code generation just takes the AST and converts it to binary code.</p>\\n<p>All compilers need to perform these steps. Most modern compilers also carry out other steps such as checking for type errors and optimizing the resulting compiled code.</p>\\n<h4>More Information:</h4>\\n<p><a href='https://medium.freecodecamp.org/a-gentler-introduction-to-programming-707453a79ee8' target='_blank' rel='nofollow'>Matt Adesanya’s “A Gentler Introduction to Programming”</a> covers compilers vs. interpreters, along with other basic programming concepts.</p>\",\"fields\":{\"slug\":\"/computer-science/compilers/\"},\"frontmatter\":{\"title\":\"Compilers\"}}},\"pathContext\":{\"slug\":\"/computer-science/compilers/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---computer-science-compilers-0ad0b8cc7e57e633e697.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Compilers</h2>\\n<h3>Programming</h3>\\n<p>At its heart, a barebones computer (aka a stored program computer) is nothing but a machine which knows how to read steps written in a fixed instruction set and execute the same. The set of instructions a computer understands is very specific to it. This is also known as machine language (<strong>opcodes</strong>). Machine Language is often alos referred to as Bianry Code.</p>\\n<p>Humans interact with computers using <strong>Programs</strong>. A program is simply a sequence of opcodes provided to the computer along with data that is necessary for executing the opcodes. </p>\\n<p>For example,</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>ADD 10, 20  // ADD is the Opcode \\n            // and 10, 20 are the two operands(data) \\n            // needed for the ADD instruction to be executed successfully</code></pre>\\n      </div>\\n<p>Humans develop programs to solve complex problems. Looking at how simple opcodes are, if we try to develop programs using opcodes alone, it will be very cumbersome and difficult to debug. To solve this problem, high level languages like C/C++, Python, Java, Javascript, etc were developed. </p>\\n<p>Now, high level languages aren’t suitable for execution by computers. Hence, the need arose for a translator that can digest the high-level language programs and convert them to machine language instructions suitable for execution by a computer.</p>\\n<h4>[HUMANS] -> [Highlevel language programs] -> [Translator] -> [Machine Language] -> [Computer]</h4>\\n<p>A <strong>compiler</strong> is a type of translator program, that translates high level languages into binary code, which is nothing but 1s and 0s. When you run your source code, a compiler translates all the code first, then produces the binary code. Then the computer takes the binary code and runs it.</p>\\n<p>If there are errors in your source code, the compiler detects and flags them. This stops the compilation process. Once all erros are fixed, the compiler converts the code and generates an executable program.</p>\\n<h2>Parts of a compiler</h2>\\n<p>Most compilers break down into three primary stages: Parsing, Transformation, and Code Generation</p>\\n<ol>\\n<li><em>Parsing</em> is taking raw code and turning it into a more abstract representation of the code.</li>\\n<li><em>Transformation</em> takes this abstract representation and manipulates to do whatever the compiler wants it to.</li>\\n<li><em>Code Generation</em> takes the transformed representation of the code and turns it into new code.</li>\\n</ol>\\n<h4>Parsing</h4>\\n<p>Parsing typically gets broken down into two phases: <strong>Lexical Analysis</strong> and <strong>Syntactic Analysis</strong>.</p>\\n<p><em>Lexical Analysis</em> takes the raw code and splits it apart into these things called tokens by a thing called a tokenizer (or lexer).</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>Tokens are an array of tiny little objects that describe an isolated piece of the syntax. \\nThey could be numbers, labels, punctuation, operators, etc.</code></pre>\\n      </div>\\n<p><em>Syntactic Analysis</em> takes the tokens and reformats them into a representation that describes each part of the syntax\\nand their relation to one another. This is known as an intermediate representation or Abstract Syntax Tree.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>An Abstract Syntax Tree, or AST for short, is a deeply nested object.\\nIt represents code in a way that is both easy to work with and tells us a lot of information.</code></pre>\\n      </div>\\n<h4>Transformation</h4>\\n<p>The next type of stage for a compiler is transformation. Again, this just takes the AST from the last step and makes changes to it.\\nIt can manipulate the AST in the same language or it can translate it into an entirely new language.</p>\\n<h4>Code Generation</h4>\\n<p>The final phase of a compiler is code generation. Sometimes compilers will do things that overlap with transformation, but for the most part code generation just takes the AST and converts it to binary code.</p>\\n<p>All compilers need to perform these steps. Most modern compilers also carry out other steps such as checking for type errors and optimizing the resulting compiled code.</p>\\n<h4>More Information:</h4>\\n<p><a href='https://medium.freecodecamp.org/a-gentler-introduction-to-programming-707453a79ee8' target='_blank' rel='nofollow'>Matt Adesanya’s “A Gentler Introduction to Programming”</a> covers compilers vs. interpreters, along with other basic programming concepts.</p>\",\"fields\":{\"slug\":\"/computer-science/compilers/\"},\"frontmatter\":{\"title\":\"Compilers\"}}},\"pathContext\":{\"slug\":\"/computer-science/compilers/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/computer-science-compilers.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/computer-science-compilers.json\n// module chunks = 10189783115851524000"],"sourceRoot":""}