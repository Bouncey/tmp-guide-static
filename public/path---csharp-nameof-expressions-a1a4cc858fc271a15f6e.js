webpackJsonp([0xc467afec2984580],{"./node_modules/json-loader/index.js!./.cache/json/csharp-nameof-expressions.json":function(e,n){e.exports={data:{markdownRemark:{html:'<h1>nameof Expressions</h1>\n<p>Sometimes you need the string name of a variable, type, or member for things such as raising an exception, logging, or firing property changed events. Prior to C# 6.0, you might use a string literal for such purposes.</p>\n<h2></h2>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>public void ProcessStudent(Student student)\n{\n    if (student == null) throw new ArgumentNullException("student");\n}</code></pre>\n      </div>\n<p>However, if the student parameter were to be renamed, you would have to remember to also modify the string literal. Now with nameof expressions, you donâ€™t have to use string literals and the compiler will be able to warn you if you are using an incorrect name.</p>\n<h2></h2>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>public void ProcessStudent(Student student)\n{\n    if (student == null) throw new ArgumentNullException(nameof(student));\n}</code></pre>\n      </div>\n<p>Some examples of where nameof expressions may be useful include:</p>\n<ul>\n<li>Throwing exceptions during parameter validation</li>\n<li>Passing an action name when setting up MVC action links</li>\n<li>Needing to pass the name of a property when firing a property changed event in a class that implements INotifyPropertyChanged</li>\n<li>Passing the name of a property when registering a XAML dependency property</li>\n<li>Including a variable, type, or member name when logging</li>\n</ul>\n<p>It should be noted that if you provide nameof with a qualified name, the compiler will generate a string for the rightmost name.</p>',fields:{slug:"/csharp/nameof-expressions/"},frontmatter:{title:"nameof Expressions"}}},pathContext:{slug:"/csharp/nameof-expressions/"}}}});
//# sourceMappingURL=path---csharp-nameof-expressions-a1a4cc858fc271a15f6e.js.map