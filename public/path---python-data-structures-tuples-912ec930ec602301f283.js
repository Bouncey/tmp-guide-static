webpackJsonp([0x199967f8c2248600],{"./node_modules/json-loader/index.js!./.cache/json/python-data-structures-tuples.json":function(e,n){e.exports={data:{markdownRemark:{html:'<h2>The Tuples</h2>\n<p>A tuple is a sequence of Python objects. Tuples are immutable which means they cannot be modified after creation, unlike lists.</p>\n<p><strong>Creation:</strong></p>\n<p>An empty <code>tuple</code> is created using a pair of round brackets, <code>()</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> empty_tuple = ()\n    >>> print(empty_tuple)\n    ()\n    >>> type(empty_tuple)\n    <class \'tuple\'>\n    >>> len(empty_tuple)\n    0</code></pre>\n      </div>\n<p>A <code>tuple</code> with elements is created by separating the elements with commas (surrounding round brackets, <code>()</code>, are optional with exceptions):</p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> tuple_1 = 1, 2, 3       # Create tuple without round brackets.\n    >>> print(tuple_1)\n    (1, 2, 3)\n    >>> type(tuple_1)\n    <class \'tuple\'>\n    >>> len(tuple_1)\n    3\n    >>> tuple_2 = (1, 2, 3)     # Create tuple with round brackets.\n    >>> print(tuple_2)\n    (1, 2, 3)\n    >>> tuple_3 = 1, 2, 3,      # Trailing comma is optional.\n    >>> print(tuple_3)\n    (1, 2, 3)\n    >>> tuple_4 = (1, 2, 3,)    # Trailing comma in round brackets is also optional.\n    >>> print(tuple_4)\n    (1, 2, 3)</code></pre>\n      </div>\n<p>A <code>tuple</code> with a single element must have the trailing comma (with or without round brackets):</p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> not_tuple = (2)    # No trailing comma makes this not a tuple.\n    >>> print(not_tuple)\n    2\n    >>> type(not_tuple)\n    <class \'int\'>\n    >>> a_tuple = (2,)     # Single element tuple. Requires trailing comma.\n    >>> print(a_tuple)\n    (2,)\n    >>> type(a_tuple)\n    <class \'tuple\'>\n    >>> len(a_tuple)\n    1\n    >>> also_tuple = 2,    # Round brackets omitted. Requires trailing comma.\n    >>> print(also_tuple)\n    (2,)\n    >>> type(also_tuple)\n    <class \'tuple\'></code></pre>\n      </div>\n<p>Round brackets are required in cases of ambiguity (if the tuple is part of a larger expression):</p>\n<blockquote>\n<p>Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, <code>f(a, b, c)</code> is a function call with three arguments, while <code>f((a, b, c))</code> is a function call with a 3-tuple as the sole argument.</p>\n</blockquote>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> print(1,2,3,4,)          # Calls print with 4 arguments: 1, 2, 3, and 4\n    1 2 3 4\n    >>> print((1,2,3,4,))        # Calls print with 1 argument: (1, 2, 3, 4,)\n    (1, 2, 3, 4)\n    >>> 1, 2, 3 == (1, 2, 3)     # Equivalent to 1, 2, (3 == (1, 2, 3))\n    (1, 2, False)\n    >>> (1, 2, 3) == (1, 2, 3)   # Use surrounding round brackets when ambiguous.\n    True</code></pre>\n      </div>\n<p>A <code>tuple</code> can also be created with the <code>tuple</code> constructor:</p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> empty_tuple = tuple()\n    >>> print(empty_tuple)\n    ()\n    >>> tuple_from_list = tuple([1,2,3,4])\n    >>> print(tuple_from_list)\n    (1, 2, 3, 4)\n    >>> tuple_from_string = tuple("Hello campers!")\n    >>> print(tuple_from_string)\n    (\'H\', \'e\', \'l\', \'l\', \'o\', \' \', \'c\', \'a\', \'m\', \'p\', \'e\', \'r\', \'s\', \'!\')\n    >>> a_tuple = 1, 2, 3\n    >>> b_tuple = tuple(a_tuple)    # If the constructor is called with a tuple for\n    the iterable,\n    >>> a_tuple is b_tuple          # the tuple argument is returned.\n    True</code></pre>\n      </div>\n<p><strong>Accessing elements of a <code>tuple</code>:</strong></p>\n<p>Elements of <code>tuples</code> are accessed and index the same way that <code>lists</code> are.</p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> my_tuple = 1, 2, 9, 16, 25\n    >>> print(my_tuple)\n    (1, 2, 9, 16, 25)</code></pre>\n      </div>\n<p><em>Zero indexed</em></p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> my_tuple[0]\n    1\n    >>> my_tuple[1]\n    2\n    >>> my_tuple[2]\n    9</code></pre>\n      </div>\n<p><em>Wrap around indexing</em></p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> my_tuple[-1]\n    25\n    >>> my_tuple[-2]\n    16</code></pre>\n      </div>\n<p><strong>Packing and Unpacking:</strong></p>\n<p>The statement <code>t = 12345, 54321, \'hello!\'</code> is an example of tuple packing: the values <code>12345</code>, <code>54321</code> and <code>\'hello!\'</code> are packed together in a tuple. The reverse operation is also possible:</p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> x, y, z = t</code></pre>\n      </div>\n<p>This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.</p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> t = 1, 2, 3    # Tuple packing.\n    >>> print(t)\n    (1, 2, 3)\n    >>> a, b, c = t    # Sequence unpacking.\n    >>> print(a)\n    1\n    >>> print(b)\n    2\n    >>> print(c)\n    3\n    >>> d, e, f = 4, 5, 6    # Multiple assignment combines packing and unpacking.\n    >>> print(d)\n    4\n    >>> print(e)\n    5\n    >>> print(f)\n    6\n    >>> a, b = 1, 2, 3       # Multiple assignment requires each variable (right)\n    have a matching element (left).\n    Traceback (most recent call last):\n      File "<stdin>", line 1, in <module>\n    ValueError: too many values to unpack (expected 2)</code></pre>\n      </div>\n<p><strong>Immutable:</strong></p>\n<p><code>tuples</code> are immutable containers, guaranteeing <strong>which</strong> objects they contain will not change. It does <strong>not</strong> guarantee that the objects they contains will not change:</p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> a_list = []\n    >>> a_tuple = (a_list,)    # A tuple (immutable) with a list (mutable) element.\n    >>> print(a_tuple)\n    ([],)\n\n    >>> a_list.append("Hello campers!")\n    >>> print(a_tuple)         # Element of the immutable is mutated.\n    ([\'Hello campers!\'],)</code></pre>\n      </div>\n<p><strong>Uses:</strong></p>\n<p>Functions can only return a single value, however, a heterogenuous <code>tuple</code> can be used to return multiple values from a function. One example is the built-in <code>enumerate</code> function that returns an iterable of heterogenuous <code>tuples</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="language-shell"><code>    >>> greeting = ["Hello", "campers!"]\n    >>> enumerator = enumerate(greeting)\n    >>> enumerator.next()\n    >>> enumerator.__next__()\n    (0, \'Hello\')\n    >>> enumerator.__next__()\n    (1, \'campers!\')</code></pre>\n      </div>\n<h3>More Inforamtion:</h3>\n<p><a href=\'https://docs.python.org/3/library/stdtypes.html#tuples\' target=\'_blank\' rel=\'nofollow\'>Python Docs - Tuples</a></p>',fields:{slug:"/python/data-structures/tuples/"},frontmatter:{title:"The Tuples"}}},pathContext:{slug:"/python/data-structures/tuples/"}}}});
//# sourceMappingURL=path---python-data-structures-tuples-912ec930ec602301f283.js.map