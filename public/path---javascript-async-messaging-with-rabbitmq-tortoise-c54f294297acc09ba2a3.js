webpackJsonp([0x1b43120a0cdb3600],{"./node_modules/json-loader/index.js!./.cache/json/javascript-async-messaging-with-rabbitmq-tortoise.json":function(n,s){n.exports={data:{markdownRemark:{html:'<p>RabbitMQ happens to be the easiest and most performant message broker platforms using the AMQ protocol out there today. Using it in a microservice architecture translates into massive performance gains, as well as the promise of reliability. In this guide, we’re going to explore the basics of using RabbitMQ with Node.js.</p>\n<h2>Theory</h2>\n<p>At its most basic level, you’d ideally have two different services interacting with one another through Rabbit - a <em>publisher</em> and a <em>subscriber</em>. A publisher typically pushes messages to Rabbit, and a subscriber listens to these messages, and executes code on the basis of those messages. Note that they can be both at the same time - a service can publish messages to Rabbit and consume messages at the same time, which makes for really powerful systems to be designed.</p>\n<p>Now a publisher typically publishes messages with a <em>routing key</em> to something called an <em>exchange</em>. A consumer listens to a <em>queue</em> on the same exchange, bound to the routing key. In architectural terms, your platform would use one Rabbit exchange, and different kinds of jobs/services would have their own routing keys and queues, for pub-sub to work effectively. Messages can be strings; they can also be native objects - AMQP client libraries do the heavy lifting of converting objects from one language to another. And yes, that does mean services can be written in different languages, so long as they’re able to understand AMQP.</p>\n<h2>Getting started</h2>\n<p>We’re going to cook up a very simple example where a publisher script publishes a message to Rabbit, containing a URL, and a consumer script listens to Rabbit, takes the published URL, calls it and displays the results. You can find the finished sample up on <a href="https://github.com/rudimk/freecodecamp-guides-rabbitmq-tortoise">Github</a>.</p>\n<p>First, let’s initialize a npm project:</p>\n<p><code>$ npm init</code></p>\n<p>You can always just hit <code>Enter</code> all the way and use the default options - or you can fill them up. Now, let’s install the packages we need. We’re going to use <a href="https://www.npmjs.com/package/tortoise">Tortoise</a>, to interact with RabbitMQ. We’re also going to use <a href="https://www.npmjs.com/package/node-cron">node-cron</a>, to schedule the actual message publishing.</p>\n<p><code>$ npm install --save tortoise node-cron</code></p>\n<p>Now your <code>package.json</code> should look a lot like this:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>{\n  "name": "freecodecamp-guides-rabbitmq-tortoise",\n  "version": "1.0.0",\n  "description": "Sample code to accompany the FreeCodeCamp guide on async messaging with RabbitMQ and Tortoise.",\n  "main": "index.js",\n  "scripts": {\n    "test": "echo \\"Error: no test specified\\" && exit 1"\n  },\n  "repository": {\n    "type": "git",\n    "url": "git+https://github.com/rudimk/freecodecamp-guides-rabbitmq-tortoise.git"\n  },\n  "keywords": [\n    "rabbitmq",\n    "tortoise",\n    "amqp"\n  ],\n  "author": "Rudraksh M.K.",\n  "license": "MIT",\n  "bugs": {\n    "url": "https://github.com/rudimk/freecodecamp-guides-rabbitmq-tortoise/issues"\n  },\n  "homepage": "https://github.com/rudimk/freecodecamp-guides-rabbitmq-tortoise#readme",\n  "dependencies": {\n    "node-cron": "^1.2.1",\n    "tortoise": "^1.0.1"\n  }\n}</code></pre>\n      </div>\n<p>Now we’re all set. Let’s create a publisher first. </p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> Tortoise <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'tortoise\'</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> cron <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'node-cron\'</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> tortoise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tortoise</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`amqp://rudimk:YouKnowWhat@$localhost:5672`</span></span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>After importing <code>tortoise</code> and <code>node-cron</code>, we’ve gone ahead and initialized a connection to RabbitMQ. Next, let’s write a quick and dirty function that publishes a message to Rabbit:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">scheduleMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">let</span> payload <span class="token operator">=</span> <span class="token punctuation">{</span>url<span class="token punctuation">:</span> <span class="token string">\'https://randomuser.me/api\'</span><span class="token punctuation">}</span>\n    tortoise\n    <span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">\'random-user-exchange\'</span><span class="token punctuation">,</span> <span class="token string">\'direct\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> durable<span class="token punctuation">:</span><span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">\'random-user-key\'</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>That’s simple enough. We’ve defined a dictionary containing a URL to the <a href="https://randomuser.me/">RandomUser.me</a> API, which is then published to the <code>random-user-exchange</code> exchange on RabbitMQ, with the <code>random-user-key</code> routing key. As mentioned earlier, the routing key is what determines who gets to consume a message. Now, let’s write a scheduling rule, to publish this message every 60 seconds.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code>cron<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token string">\'60 * * * * *\'</span><span class="token punctuation">,</span> scheduleMessage<span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>And our publisher’s ready! But it’s really no good without a consumer to actually consume these messages! But first, we do need a library that can call the URL in these messages. Personally, I use <code>superagent</code>: <code>npm install --save superagent</code>.</p>\n<p>Now, in <code>consumer.js</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">const</span> Tortoise <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'tortoise\'</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> superagent <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'superagent\'</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> tortoise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tortoise</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`amqp://rudimk:YouKnowWhat@$localhost:5672`</span></span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>Next, let’s write an async function that calls a URL and displays the result:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getURL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t<span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token keyword">await</span> superagent<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>\n\t<span class="token keyword">return</span> response<span class="token punctuation">.</span>body\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>Time to write code to actually consume messages:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code>tortoise\n<span class="token punctuation">.</span><span class="token function">queue</span><span class="token punctuation">(</span><span class="token string">\'random-user-queue\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> durable<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment" spellcheck="true">// Add as many bindings as needed </span>\n<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">\'random-user-exchange\'</span><span class="token punctuation">,</span> <span class="token string">\'direct\'</span><span class="token punctuation">,</span> <span class="token string">\'random-user-key\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> durable<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">.</span><span class="token function">prefetch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> ack<span class="token punctuation">,</span> nack<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment" spellcheck="true">// Handle </span>\n  <span class="token keyword">let</span> payload <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>\n  <span class="token function">getURL</span><span class="token punctuation">(</span>payload<span class="token punctuation">[</span><span class="token string">\'url\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Job result: \'</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token function">ack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// or nack()</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>Here, we’ve told <code>tortoise</code> to listen to the <code>random-user-queue</code>, that’s bound to the <code>random-user-key</code> on the <code>random-user-exchange</code>. Once a message is received, the payload is retrieved from <code>msg</code>, and is passed along to the <code>getURL</code> function, which in turn returns a Promise with the desired JSON response from the RandomUser API.</p>\n<h2>Conclusion</h2>\n<p>The simplicity associated with using RabbitMQ for messaging is unparalleled, and it’s very easy to come up with really complex microservice patterns, with just a few lines of code. The best part is that the logic behind messaging doesn’t really change across languages - Crystal or Go or Python or Ruby work with Rabbit in pretty much the same way - this means you can have services written in different languages all communicating with each other effortlessly, enabling you to use the best language for the job.</p>',fields:{slug:"/javascript/async-messaging-with-rabbitmq-tortoise/"},frontmatter:{title:"Async messaging with RabbitMQ and Tortoise"}}},pathContext:{slug:"/javascript/async-messaging-with-rabbitmq-tortoise/"}}}});
//# sourceMappingURL=path---javascript-async-messaging-with-rabbitmq-tortoise-c54f294297acc09ba2a3.js.map