{"version":3,"sources":["webpack:///path---clojure-hashmaps-bba1458c9def8ac77042.js","webpack:///./.cache/json/clojure-hashmaps.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/clojure-hashmaps.json","module","exports","data","markdownRemark","html","fields","slug","frontmatter","title","pathContext"],"mappings":"AAAAA,cAAc,qBAERC,0EACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,opLAA6sIC,QAAijDC,KAAA,sBAA4BC,aAAgBC,MAAA,sBAA6BC,aAAgBH,KAAA","file":"path---clojure-hashmaps-bba1458c9def8ac77042.js","sourcesContent":["webpackJsonp([8662892999524572000],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/clojure-hashmaps.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>A hashmap is a collection that maps keys to values. They have various names in other languages; Python refers to them as dictionaries, and Javascript’s objects essentially work like hashmaps.</p>\\n<p>A hashmap can, like many collections, be constructed in two ways. There is the constructor function:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>;; Note that each argument is *prepended* to the hashmap, not appended.\\n(def a-hashmap (hash-map :a 1 :b 2 :c 3))\\na-hashmap\\n; => {:c 3, :b 2, :a 1}</code></pre>\\n      </div>\\n<p>You can also define them using a hashmap literal. This is often more concise and clear. Using commas to separate key/value pairs in hashmaps is recommended, as it can make the boundaries more clear.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>;; This hashmap is actually in the right order, unlike the one above.\\n(def another-hashmap {:a 1, :b 2, :c 3})\\nanother-hashmap\\n; => {:a 1, :b 2, :c 3}</code></pre>\\n      </div>\\n<h2>Keywords and retrieving values from hashmaps</h2>\\n<p>Hold up. What is this? <code>:a</code>? <code>:b</code>? <code>:c</code>? Those look odd. Those, you see, are keywords. They’re called <em>key</em>-words because they’re often used as keys in hashmaps.</p>\\n<p>Why are they often used as keys? Well, unlike strings, keywords can be used as functions to extract values from a hashmap; no need for <code>get</code> or <code>nth</code>!</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(def string-hashmap {\\\"a\\\" 1, \\\"b\\\" 2, \\\"c\\\" 3})\\n(\\\"a\\\" string-hashmap)\\n; => ClassCastException java.lang.String cannot be cast to clojure.lang.IFn\\n\\n(def keyword-hashmap {:a 1, :b 2, :c 3})\\n(:a keyword-hashmap)\\n; => 1\\n\\n;; You can also pass a keyword a default value in case it's not found, just like get.\\n(:not-in-the-hashmap keyword-hashmap \\\"not found!\\\")\\n; => \\\"not found!\\\"</code></pre>\\n      </div>\\n<h2>Converting other collections to hashmaps</h2>\\n<p>Converting to a hashmap is tricky. To demonstrate, let’s try using it like <code>vec</code> or <code>seq</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(hash-map [:a 1 :b 2 :c 3])\\n; => IllegalArgumentException No value supplied for key: [:a 1 :b 2 :c 3]</code></pre>\\n      </div>\\n<p>The <code>hash-map</code> function thinks that we’re trying to create a hashmap with <code>[:a 1 :b 2 :c 3]</code> as one of the keys. Watch what happens if we give it the right number of arguments:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(hash-map [:a 1 :b 2 :c 3] \\\"foo\\\")\\n; => {[:a 1 :b 2 :c 3] \\\"foo\\\"}</code></pre>\\n      </div>\\n<p>To convert a sequence to a hashmap, you’ll need to use and understand <code>apply</code>. Luckily, this is pretty simple: <code>apply</code> essentially destructures a collection before applying a function to it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>;; These two expressions are exactly the same.\\n(+ 1 2 3)\\n; => 6\\n(apply + [1 2 3])\\n; => 6</code></pre>\\n      </div>\\n<p>This is how you would convert a vector to a hashmap:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(apply hash-map [:a 1 :b 2 :c 3])\\n; => {:c 3, :b 2, :a 1}\\n\\n;; This is the same as:\\n(hash-map :a 1 :b 2 :c 3)\\n; => {:c 3, :b 2, :a 1}</code></pre>\\n      </div>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" title=\\\":rocket:\\\" alt=\\\":rocket:\\\" class=\\\"forum-image\\\"> <a href='https://ideone.com/k9cOjo' target='_blank' rel='nofollow'>IDEOne it!</a></p>\\n<h2>Update a hashmap</h2>\\n<p>You can update values inside a hashmap using <code>assoc</code>. This allows you to append new key/value pairs or change old ones.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(def outdated-hashmap {:a 1, :b 2, :c 3})\\n\\n(def newer-hashmap (assoc outdated-hashmap :d 4))\\nnewer-hashmap\\n; => {:a 1, :b 2, :c 3, :d 4}\\n\\n(def newest-hashmap (assoc newer-hashmap :a 22))\\nnewest-hashmap\\n; => {:a 22, :b 2, :c 3, :d 4}\\n\\n;; Note that outdated-hashmap has not been mutated by any of this.\\n;; Assoc is pure and functional.\\noutdated-hashmap\\n; => {:a 1, :b 2, :c 3}</code></pre>\\n      </div>\\n<h2>When to use a hashmap?</h2>\\n<p>A hashmap is useful when you want to give names to your variables. If you’re ever thinking to yourself, <em>“What if I used an object…”</em> before you snap out of it and realise you’re using Clojure, try using a hashmap.</p>\\n<p>They are also useful if you want to associate two different values with each other. Take, for example, a ROT13 cipher: you could associate <code>\\\\A</code> with <code>\\\\N</code>, <code>\\\\B</code> with <code>\\\\M</code>, etc. (This would be long and boring to write in most languages, but Clojure has some functions that can generate it for you and make it <em>fun!</em>)</p>\\n<p>| <a href=\\\"//forum.freecodecamp.com/t/clojure-vectors/18421\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2\\\" title=\\\":point_left:\\\" alt=\\\":point_left:\\\" class=\\\"forum-image\\\"> Previous</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" title=\\\":book:\\\" alt=\\\":book:\\\" class=\\\"forum-image\\\"> Home <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" title=\\\":book:\\\" alt=\\\":book:\\\" class=\\\"forum-image\\\"></a> | Next <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2\\\" title=\\\":point_right:\\\" alt=\\\":point_right:\\\" class=\\\"forum-image\\\"> |<br>\\n| <a href=\\\"//forum.freecodecamp.com/t/clojure-vectors/18421\\\">Vectors</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\">Table of Contents</a> | To Be Added |</p>\",\"fields\":{\"slug\":\"/clojure/hashmaps/\"},\"frontmatter\":{\"title\":\"Clojure Hashmaps\"}}},\"pathContext\":{\"slug\":\"/clojure/hashmaps/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---clojure-hashmaps-bba1458c9def8ac77042.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>A hashmap is a collection that maps keys to values. They have various names in other languages; Python refers to them as dictionaries, and Javascript’s objects essentially work like hashmaps.</p>\\n<p>A hashmap can, like many collections, be constructed in two ways. There is the constructor function:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>;; Note that each argument is *prepended* to the hashmap, not appended.\\n(def a-hashmap (hash-map :a 1 :b 2 :c 3))\\na-hashmap\\n; => {:c 3, :b 2, :a 1}</code></pre>\\n      </div>\\n<p>You can also define them using a hashmap literal. This is often more concise and clear. Using commas to separate key/value pairs in hashmaps is recommended, as it can make the boundaries more clear.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>;; This hashmap is actually in the right order, unlike the one above.\\n(def another-hashmap {:a 1, :b 2, :c 3})\\nanother-hashmap\\n; => {:a 1, :b 2, :c 3}</code></pre>\\n      </div>\\n<h2>Keywords and retrieving values from hashmaps</h2>\\n<p>Hold up. What is this? <code>:a</code>? <code>:b</code>? <code>:c</code>? Those look odd. Those, you see, are keywords. They’re called <em>key</em>-words because they’re often used as keys in hashmaps.</p>\\n<p>Why are they often used as keys? Well, unlike strings, keywords can be used as functions to extract values from a hashmap; no need for <code>get</code> or <code>nth</code>!</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(def string-hashmap {\\\"a\\\" 1, \\\"b\\\" 2, \\\"c\\\" 3})\\n(\\\"a\\\" string-hashmap)\\n; => ClassCastException java.lang.String cannot be cast to clojure.lang.IFn\\n\\n(def keyword-hashmap {:a 1, :b 2, :c 3})\\n(:a keyword-hashmap)\\n; => 1\\n\\n;; You can also pass a keyword a default value in case it's not found, just like get.\\n(:not-in-the-hashmap keyword-hashmap \\\"not found!\\\")\\n; => \\\"not found!\\\"</code></pre>\\n      </div>\\n<h2>Converting other collections to hashmaps</h2>\\n<p>Converting to a hashmap is tricky. To demonstrate, let’s try using it like <code>vec</code> or <code>seq</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(hash-map [:a 1 :b 2 :c 3])\\n; => IllegalArgumentException No value supplied for key: [:a 1 :b 2 :c 3]</code></pre>\\n      </div>\\n<p>The <code>hash-map</code> function thinks that we’re trying to create a hashmap with <code>[:a 1 :b 2 :c 3]</code> as one of the keys. Watch what happens if we give it the right number of arguments:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(hash-map [:a 1 :b 2 :c 3] \\\"foo\\\")\\n; => {[:a 1 :b 2 :c 3] \\\"foo\\\"}</code></pre>\\n      </div>\\n<p>To convert a sequence to a hashmap, you’ll need to use and understand <code>apply</code>. Luckily, this is pretty simple: <code>apply</code> essentially destructures a collection before applying a function to it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>;; These two expressions are exactly the same.\\n(+ 1 2 3)\\n; => 6\\n(apply + [1 2 3])\\n; => 6</code></pre>\\n      </div>\\n<p>This is how you would convert a vector to a hashmap:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(apply hash-map [:a 1 :b 2 :c 3])\\n; => {:c 3, :b 2, :a 1}\\n\\n;; This is the same as:\\n(hash-map :a 1 :b 2 :c 3)\\n; => {:c 3, :b 2, :a 1}</code></pre>\\n      </div>\\n<p><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2\\\" title=\\\":rocket:\\\" alt=\\\":rocket:\\\" class=\\\"forum-image\\\"> <a href='https://ideone.com/k9cOjo' target='_blank' rel='nofollow'>IDEOne it!</a></p>\\n<h2>Update a hashmap</h2>\\n<p>You can update values inside a hashmap using <code>assoc</code>. This allows you to append new key/value pairs or change old ones.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>(def outdated-hashmap {:a 1, :b 2, :c 3})\\n\\n(def newer-hashmap (assoc outdated-hashmap :d 4))\\nnewer-hashmap\\n; => {:a 1, :b 2, :c 3, :d 4}\\n\\n(def newest-hashmap (assoc newer-hashmap :a 22))\\nnewest-hashmap\\n; => {:a 22, :b 2, :c 3, :d 4}\\n\\n;; Note that outdated-hashmap has not been mutated by any of this.\\n;; Assoc is pure and functional.\\noutdated-hashmap\\n; => {:a 1, :b 2, :c 3}</code></pre>\\n      </div>\\n<h2>When to use a hashmap?</h2>\\n<p>A hashmap is useful when you want to give names to your variables. If you’re ever thinking to yourself, <em>“What if I used an object…”</em> before you snap out of it and realise you’re using Clojure, try using a hashmap.</p>\\n<p>They are also useful if you want to associate two different values with each other. Take, for example, a ROT13 cipher: you could associate <code>\\\\A</code> with <code>\\\\N</code>, <code>\\\\B</code> with <code>\\\\M</code>, etc. (This would be long and boring to write in most languages, but Clojure has some functions that can generate it for you and make it <em>fun!</em>)</p>\\n<p>| <a href=\\\"//forum.freecodecamp.com/t/clojure-vectors/18421\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2\\\" title=\\\":point_left:\\\" alt=\\\":point_left:\\\" class=\\\"forum-image\\\"> Previous</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\"><img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" title=\\\":book:\\\" alt=\\\":book:\\\" class=\\\"forum-image\\\"> Home <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2\\\" title=\\\":book:\\\" alt=\\\":book:\\\" class=\\\"forum-image\\\"></a> | Next <img src=\\\"//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2\\\" title=\\\":point_right:\\\" alt=\\\":point_right:\\\" class=\\\"forum-image\\\"> |<br>\\n| <a href=\\\"//forum.freecodecamp.com/t/clojure-vectors/18421\\\">Vectors</a> | <a href=\\\"//forum.freecodecamp.com/t/clojure-resources/18422\\\">Table of Contents</a> | To Be Added |</p>\",\"fields\":{\"slug\":\"/clojure/hashmaps/\"},\"frontmatter\":{\"title\":\"Clojure Hashmaps\"}}},\"pathContext\":{\"slug\":\"/clojure/hashmaps/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/clojure-hashmaps.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/clojure-hashmaps.json\n// module chunks = 8662892999524572000"],"sourceRoot":""}