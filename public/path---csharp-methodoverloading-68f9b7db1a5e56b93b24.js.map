{"version":3,"sources":["webpack:///path---csharp-methodoverloading-68f9b7db1a5e56b93b24.js","webpack:///./.cache/json/csharp-methodoverloading.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/csharp-methodoverloading.json","module","exports","data","markdownRemark","html","fields","slug","frontmatter","title","pathContext"],"mappings":"AAAAA,cAAc,qBAERC,kFACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,+zDAAiuDC,QAA+IC,KAAA,8BAAoCC,aAAgBC,MAAA,wBAA+BC,aAAgBH,KAAA","file":"path---csharp-methodoverloading-68f9b7db1a5e56b93b24.js","sourcesContent":["webpackJsonp([18298459065376125000],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/csharp-methodoverloading.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Method Overloading</h1>\\n<p>Default parameters were introduced in C# version 4.0, but up until that, C# coders have been using a different technique, which basically does the same, called method overloading. It allows the programmer do define several methods with the same name, as long as they take a different set of parameters. When you use the classes of the .NET framework, you will soon realize that method overloading is used all over the place.</p>\\n<h2>Example</h2>\\n<ol>\\n<li>\\n<p>Create a class file named Person.cs &#x26; input the following code.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>public class Person\\n{\\npublic string FirstName { get; private set; }\\npublic string LastName { get; set; }\\n\\npublic Person(string firstName, string lastName)\\n{\\n    this.FirstName = firstName;\\n    this.LastName = lastName;\\n}\\n\\npublic string SayHello(string name)\\n{\\n    return \\\"Hello there, \\\" + name;\\n}\\n\\npublic string SayHello(Person person)\\n{\\n    return \\\"Hello there, \\\" + person.FirstName + \\\" \\\" + person.LastName;\\n}\\n}</code></pre>\\n      </div>\\n</li>\\n<li>\\n<p>In your default Program.cs file you can call now this class Person using the method overloading.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Program\\n{\\n    static void Main(string[] args)\\n    {\\n        Person person = new Person(\\\"Jane\\\", \\\"Doe\\\");\\n        Console.WriteLine(person.SayHello(\\\"Peter Smith\\\"));\\n\\n        Person friend = new Person(\\\"Chuck\\\", \\\"Norris\\\");\\n        Console.WriteLine(person.SayHello(friend));\\n\\n        Console.ReadKey();</code></pre>\\n      </div>\\n</li>\\n</ol>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    }\\n}</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code></code></pre>\\n      </div>\",\"fields\":{\"slug\":\"/csharp/methodoverloading/\"},\"frontmatter\":{\"title\":\"Method Overloading\"}}},\"pathContext\":{\"slug\":\"/csharp/methodoverloading/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---csharp-methodoverloading-68f9b7db1a5e56b93b24.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Method Overloading</h1>\\n<p>Default parameters were introduced in C# version 4.0, but up until that, C# coders have been using a different technique, which basically does the same, called method overloading. It allows the programmer do define several methods with the same name, as long as they take a different set of parameters. When you use the classes of the .NET framework, you will soon realize that method overloading is used all over the place.</p>\\n<h2>Example</h2>\\n<ol>\\n<li>\\n<p>Create a class file named Person.cs &#x26; input the following code.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>public class Person\\n{\\npublic string FirstName { get; private set; }\\npublic string LastName { get; set; }\\n\\npublic Person(string firstName, string lastName)\\n{\\n    this.FirstName = firstName;\\n    this.LastName = lastName;\\n}\\n\\npublic string SayHello(string name)\\n{\\n    return \\\"Hello there, \\\" + name;\\n}\\n\\npublic string SayHello(Person person)\\n{\\n    return \\\"Hello there, \\\" + person.FirstName + \\\" \\\" + person.LastName;\\n}\\n}</code></pre>\\n      </div>\\n</li>\\n<li>\\n<p>In your default Program.cs file you can call now this class Person using the method overloading.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>class Program\\n{\\n    static void Main(string[] args)\\n    {\\n        Person person = new Person(\\\"Jane\\\", \\\"Doe\\\");\\n        Console.WriteLine(person.SayHello(\\\"Peter Smith\\\"));\\n\\n        Person friend = new Person(\\\"Chuck\\\", \\\"Norris\\\");\\n        Console.WriteLine(person.SayHello(friend));\\n\\n        Console.ReadKey();</code></pre>\\n      </div>\\n</li>\\n</ol>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>    }\\n}</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code></code></pre>\\n      </div>\",\"fields\":{\"slug\":\"/csharp/methodoverloading/\"},\"frontmatter\":{\"title\":\"Method Overloading\"}}},\"pathContext\":{\"slug\":\"/csharp/methodoverloading/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/csharp-methodoverloading.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/csharp-methodoverloading.json\n// module chunks = 18298459065376125000"],"sourceRoot":""}