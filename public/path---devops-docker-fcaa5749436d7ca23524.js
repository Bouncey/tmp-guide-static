webpackJsonp([0x5ce2605c1ecf9000],{"./node_modules/json-loader/index.js!./.cache/json/devops-docker.json":function(e,n){e.exports={data:{markdownRemark:{html:'<h2>Docker</h2>\n<p>Docker uses containers (a runtime instance of an image) to create environments that can easily build, ship, and run applications. The main benefit is that Docker containers run completely isolated from the host environment by default, only accessing host files and ports if configured to do so. This is a great alternative to virutal machines(VMs) that are often resource intensive. VMs disk image and application state are an entanglement of OS settings, system-installed dependencies, OS security patches, and other easy-to-lose, hard-to-replicate ephemera.</p>\n<p>Docker is an open-source project based on Linux containers. It uses Linux Kernel features like namespaces and control groups to create containers on top of an operating system.</p>\n<h3>What is containerization then:</h3>\n<p>Simply put, it is nothing more than packaging of a process/application and it’s dependencies into a distributable image which can run in isolation. </p>\n<h3>Why do we need Docker:</h3>\n<p>It makes the life of software engineers very smooth as they will always work on the same development environment.\nIt helps in sharing the final product to customers/other teams without worrying about environment issues.\nIt reduces the amount of hardware we need to run our applications by not wasting them for unnecessary OS layer.</p>\n<h2>Fundamental Docker Concepts</h2>\n<h3>Docker Engine</h3>\n<p>Docker engine is the layer on which Docker runs. It’s a lightweight runtime and tooling that manages containers, images, builds, and more. It runs natively on Linux systems and is made up of:</p>\n<ol>\n<li>\n<p>A Docker Daemon that runs in the host computer.</p>\n</li>\n<li>\n<p>A Docker Client that then communicates with the Docker Daemon to execute commands.</p>\n</li>\n<li>\n<p>A REST API for interacting with the Docker Daemon remotely.</p>\n</li>\n</ol>\n<h3>Docker Client</h3>\n<p>The Docker Client is what you, as the end-user of Docker, communicate with. Think of it as the UI for Docker.</p>\n<h3>Docker Daemon</h3>\n<p>The Docker daemon is what actually executes commands sent to the Docker Client — like building, running, and distributing your containers. The Docker Daemon runs on the host machine, but as a user, you never communicate directly with the Daemon. The Docker Client can run on the host machine as well, but it’s not required to. It can run on a different machine and communicate with the Docker Daemon that’s running on the host machine.</p>\n<h3>Dockerfile</h3>\n<p>A Dockerfile is where you write the instructions to build a Docker image. These instructions can be:\n<strong>RUN apt-get y install some-package</strong>: to install a software package\n<strong>EXPOSE 8000</strong>: to expose a port\n<strong>ENV ANT_HOME /usr/local/apache-ant</strong> to pass an environment variable and so forth. Once you’ve got your Dockerfile set up, you can use the docker build command to build an image from it. Here’s an example of a Dockerfile:</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code># Start with ubuntu 14.04\nFROM ubuntu:14.04\n\nMAINTAINER freeCodeCamp@gmail.com\n\n# For SSH access and port redirection\nENV ROOTPASSWORD sample\n\n# Turn off prompts during installations\nENV DEBIAN_FRONTEND noninteractive\nRUN echo "debconf shared/accepted-oracle-license-v1-1 select true" | debconf-set-selections\nRUN echo "debconf shared/accepted-oracle-license-v1-1 seen true" | debconf-set-selections\n\n# Update packages\nRUN apt-get -y update\n\n# Install system tools / libraries\nRUN apt-get -y install python3-software-properties \\\n    software-properties-common \\\n    bzip2 \\\n    ssh \\\n    net-tools \\\n    vim \\\n    curl \\\n    expect \\\n    git \\\n    nano \\\n    wget \\\n    build-essential \\\n    dialog \\\n    make \\\n    build-essential \\\n    checkinstall \\\n    bridge-utils \\\n    virt-viewer \\\n    python-pip \\\n    python-setuptools \\\n    python-dev\n\n# Install Node, npm\nRUN curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash -\nRUN apt-get install -y nodejs\n\n# Add oracle-jdk7 to repositories\nRUN add-apt-repository ppa:webupd8team/java\n\n# Make sure the package repository is up to date\nRUN echo "deb http://archive.ubuntu.com/ubuntu precise main universe" > /etc/apt/sources.list\n\n# Update apt\nRUN apt-get -y update\n\n# Install oracle-jdk7\nRUN apt-get -y install oracle-java7-installer\n\n# Export JAVA_HOME variable\nENV JAVA_HOME /usr/lib/jvm/java-7-oracle\n\n# Run sshd\nRUN apt-get install -y openssh-server\nRUN mkdir /var/run/sshd\nRUN echo "root:$ROOTPASSWORD" | chpasswd\nRUN sed -i \'s/PermitRootLogin without-password/PermitRootLogin yes/\' /etc/ssh/sshd_config\n\n# SSH login fix. Otherwise user is kicked off after login\nRUN sed \'s@session\\s*required\\s*pam_loginuid.so@session optional pam_loginuid.so@g\' -i /etc/pam.d/sshd\n\n# Expose Node.js app port\nEXPOSE 8000\n\n# Create tap-to-android app directory\nRUN mkdir -p /usr/src/my-app\nWORKDIR /usr/src/my-app\n\n# Install app dependencies\nCOPY . /usr/src/my-app\nRUN npm install\n\n# Add entrypoint\nADD entrypoint.sh /entrypoint.sh\nRUN chmod +x /entrypoint.sh\nENTRYPOINT ["/entrypoint.sh"]\n\nCMD ["npm", "start"]</code></pre>\n      </div>\n<h4>More Information:</h4>\n<ul>\n<li><a href="https://medium.freecodecamp.org/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b">Beginner friendly doc</a></li>\n<li><a href="https://docs.docker.com/get-started/">Docker Official docs</a></li>\n<li><a href="http://training.play-with-docker.com/">Try Docker Online</a></li>\n</ul>',fields:{slug:"/devops/docker/"},frontmatter:{title:"Docker"}}},pathContext:{slug:"/devops/docker/"}}}});
//# sourceMappingURL=path---devops-docker-fcaa5749436d7ca23524.js.map