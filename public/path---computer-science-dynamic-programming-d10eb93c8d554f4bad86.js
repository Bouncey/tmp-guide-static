webpackJsonp([0x22d83b7b7b494e00],{"./node_modules/json-loader/index.js!./.cache/json/computer-science-dynamic-programming.json":function(n,s){n.exports={data:{markdownRemark:{html:'<h2>Dynamic Programming</h2>\n<p>Dynamic Programming(DP) is a programming technique for solving problems where the computations of its subproblems overlap: you write your program in a way that avoids recomputing already solved problems.\nThis technique, it’s usually applied in conjunction with memoization which is an optimization technique where you cache previously computed results, and return the cached result when the same computation is needed again.</p>\n<p>An example with Fibonacci’s series which is defined as:</p>\n<p><code>F(N) = F(N-1) + F(N-2)</code></p>\n<p>This is the tree to find F(5):</p>\n<p><img src="https://i.stack.imgur.com/59Rpw.png" alt="Fibonacci serie&#x27;s tree"></p>\n<p>To compute F(5) it will need to compute many times the same F(i). Using recursion:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>\n        <span class="token keyword">return</span> n\n    <span class="token keyword">return</span> fib<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>And below is the optimised solution (using DP)</p>\n<p>For F(5), this solution will generate the calls depicted in the image above, running in O(2^N).</p>\n<p>Here is an optimised solution which uses DP and memoization:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code>lookup <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># Create a lookup-table (a map) inizialized with the first 2 Fibonacci\'s numbers</span>\n\n<span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n    <span class="token keyword">if</span> n <span class="token keyword">in</span> lookup<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># If n is already computed</span>\n        <span class="token keyword">return</span> n <span class="token comment" spellcheck="true"># Return the previous computed solution</span>\n    <span class="token keyword">else</span> \n        lookup<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> fib<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Else, do the recursion.</span>\n    <span class="token keyword">return</span> lookup<span class="token punctuation">[</span>n<span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>Caching computed solutions in a lookup table, and query it before go recursion will let the program have a running time of O(N).</p>\n<h4>More Information:</h4>\n<p><a href="https://stackoverflow.com/questions/1065433/what-is-dynamic-programming%22">What is dynamic programming on StackOverflow</a>\n<a href="https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming">Difference between memoization and DP on StackOverflow</a></p>',fields:{slug:"/computer-science/dynamic-programming/"},frontmatter:{title:"Dynamic Programming"}}},pathContext:{slug:"/computer-science/dynamic-programming/"}}}});
//# sourceMappingURL=path---computer-science-dynamic-programming-d10eb93c8d554f4bad86.js.map